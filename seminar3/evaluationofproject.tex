\section{Evaluation of exercise}
During the exercise we were a team of eight students that were given the task
to develop a command line calculator. For first sprint the goal was to make it
work with addition, subtraction, division and multiplication. For the second
sprint the goal was to add functions such as the power of and square root as
well as adding paranthesis so more advanced calculations could be made.

During this exercise we used some parts from XP and some parts from Scrum. The
two most obvious parts that relates back to the two principles is the use of
pair programming which clearly is a practice that promote face-to-face
discussions. The second part was our scrum retrospective meeting after the
first sprint. We saw a potential in increasing our efficiency by dividing the
stories a little bit different during the next sprint planning meeting. This
relates back to the second principle.

There were a few more smaller subtle parts during the exercise that can be
related to the two principles. First out is that during our first daily meeting we
tried to solve different problems. Later on we realised that this is not the
best time to solve all problems because all developers are now focused on what
could be a small problem. Instead when someone had a problem and mentioned it
during the daily meeting someone else volunteered to help out or give an
explanation after the meeting. This relates back to the first principle that
face-to-face conversions are good for conveying information though only the
stakeholders it concerns should be listening.

During our project we also took time during each daily meeting to discuss what
worked well in general during the previous day when it comes to estimation of
tasks and
division of work. Almost like a small scrum retrospective but everyday. This
clearly relates back to the second principle that on regular intervals the team
should reflect on the process and how to improve efficiency.

Another part during the exercise which relates to the first principle is how we
solved different problems such as what kind of interfaces each module/class
should have. Instead of drawing UML diagrams and creating a good design before
writing the code each pair of programmers talked with the other pairs which
depended on them. As an example the developers that created the validator spoke
with the developers that implemented the parser and decided between them what
the interface inbetween would look like. The developers that handle the
formatter didn't care and didn't bother to participate in that discussion
because the formatter didn't depend on either the validator or parser.
